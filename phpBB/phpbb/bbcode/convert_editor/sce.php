<?php
/**
*
* This file is part of the phpBB Forum Software package.
*
* @copyright (c) phpBB Limited <https://www.phpbb.com>
* @license GNU General Public License, version 2 (GPL-2.0)
*
* For full copyright and license information, please see
* the docs/CREDITS.txt file.
*
*/

namespace phpbb\bbcode\convert_editor;

use s9e\TextFormatter\Configurator;
use s9e\TextFormatter\Plugins\BBCodes\Configurator as BBCodeConfigurator;
use s9e\TextFormatter\Configurator\Items\AttributeFilters\Regexp as RegexpFilter;
use s9e\TextFormatter\Configurator\Items\UnsafeTemplate;

use phpbb\bbcode\xsl_parse_helper as xsl_parse_helper;

function var_dump(){
	call_user_func_array("var_dump", func_get_args());
	ob_flush();
}

/**
*
* Note: This code includes ob_start() to ease the javascript building by having it syntax highlighted!
* 		Any use of var_dump() or any other output debugging should be used with that into account.
*
*/
class sce extends base
{

	/**
	 * Config object
	 * @var \phpbb\config\config
	 */
	protected $config;

	/**
	 * Database connection
	 * @var \phpbb\db\driver\driver_interface
	 */
	protected $db;

	/**
	* Event dispatcher object
	* @var \phpbb\event\dispatcher_interface
	*/
	protected $phpbb_dispatcher;
	
	
	/**
	 * Stores all js variables in order to avoid clashes
	 */
	protected $js_variables;


	/**
	 * Constructor
	 * 
	 *
	 * @param string|bool $error Any error that occurs is passed on through this reference variable otherwise false
	 * @param string $phpbb_root_path Relative path to phpBB root
	 * @param string $phpEx PHP file extension
	 * @param \phpbb\auth\auth $auth Auth object
	 * @param \phpbb\config\config $config Config object
	 * @param \phpbb\db\driver\driver_interface Database object
	 */
	public function __construct($phpbb_root_path, $phpEx, \phpbb\auth\auth $auth, \phpbb\config\config $config, \phpbb\db\driver\driver_interface $db, \phpbb\user $user, \phpbb\event\dispatcher_interface $phpbb_dispatcher)
	{
		$this->config = $config;
		$this->db = $db;
		$this->phpbb_dispatcher = $phpbb_dispatcher;
		$this->js_variables = array();
		
		
		ob_start();
		// This is the topmost of the file. File editors support the embedded HTML with javascript.
		// This allows javascript code to be syntax highlighted by the editors.
		?><script><?php
		ob_end_clean();
	}
	
	
	/**
	 * @param string original_name A string tried as default value for name (eases readability later).
	 *								It gets suffixed with an integer if it was already defined.
	 * @return A string that has never been generated by this method, in this instance before
	 */
	protected function make_new_js_var($original_name)
	{
		if(!isset($this->js_variables[$original_name]))
		{
			$this->js_variables[$original_name] = 1;
			return $original_name;
		}
		
		$append = 0;
		do
		{
			$append++;
		}while(isset($this->js_variables[$original_name . $append]));
		
		$this->js_variables[$original_name . $append] = 1;
		return $original_name . $append;
		
	}
	
	protected function parse_case($bbcode_name, &$parsed_child)
	{
		
		$vars = array();
		foreach ($parsed_child['case'] as $test_result => &$execution)
		{
			foreach ($execution['vars'] as $execution_var)
			{
				if ($execution_var['isAttribute'])
				{
					$vars[$execution_var['name']] = 1;
				}
			}
			
			$this->parse_node($bbcode_name, $execution['children']);
?>
			case '<?=$test_result?>':
<?php 
			$execution['js']['type'] = 'SWITCH_CASE';
			$execution['js']['before'] = ob_get_contents();
			ob_clean();
			?>
			break;
<?php
			$execution['js']['after'] = ob_get_contents();
			ob_clean();
		}
		
		foreach ($vars as $var => $one)
		{
			?>
		xslt.setParameter('<?=$var?>', attributes['<?=$var?>']);
<?php
		}
		?>
		var conditionResult = xslt.transformToFragment(
			'<<?=$bbcode_name?> d="<?=$parsed_child['num']?>"></<?=$bbcode_name?>>',
			document
		).firstChild.nodeValue;
		
		switch(conditionResult[0]){
<?php
		$parsed_child['js']['type'] = 'SWITCH_DEFINITION';
		$parsed_child['js']['before'] = ob_get_contents();
		ob_clean();
		
?>
		}
<?php	
		
		$parsed_child['js']['after'] = ob_get_contents();
		ob_clean();
	}
	
	protected function parse_node($bbcode, &$parsed_template)
	{
		// This assumes that there are no text nodes simblings of each other
		// That not being true, however, has only a minor performance impact
		$strings = array();
		
		foreach ($parsed_template as &$parsed_child)
		{
			if (isset($parsed_child['case']))
			{
				$this->parse_case($bbcode, $parsed_child);
			}
			else
			{
				if ($parsed_child['xsl'])
				{
					switch ($parsed_child['tagName'])
					{						
						case 'apply-templates':
							
							?>.innerHTML += content;
<?php
							$parsed_child['js']['type'] = 'PARSED_CHILDREN_SET';
							$parsed_child['js']['before'] = ob_get_contents();
							ob_clean();
							
						break;
						case 'value-of':
							// Here it is easier due to how TextFormatter uses this tag
							$varData = $parsed_child['vars'][0];
							$js_var_name = $this->make_new_js_var('textNode');
							?>
						var <?=$js_var_name?> = document.createTextNode(<?php
							
							if ($varData['isAttribute'])
							{
								// TODO!! First check how variables in js code should be called
								?>attributes['<?=$varData['name']?>']<?php
							}
							else
							{
								echo xsl_parse_helper::EDITOR_JS_GLOBAL_OBJ . '.' . $varData['prefixedName'];
							}
						?>);
<?php					
							$parsed_child['js']['nodeName'] = $js_var_name;
							$parsed_child['js']['type'] = 'NODE_DEFINITION';
							$parsed_child['js']['parentEditable'] = $varData['isAttribute'];
							$parsed_child['js']['varName'] = $varData['name'];
							$parsed_child['js']['before'] = ob_get_contents();
							ob_clean();
						break;
						
						
					}
				}
				else
				{
					if ($parsed_child['tagName'][0] === '#')
					{
						// This is a text node. It requires special treatment
						$js_var_name = $this->make_new_js_var('textNode');
						?>
						var <?=$js_var_name?> = document.createTextNode('<?=$parsed_child['node']->data?>');
<?php					
					}
					else
					{	
						
						$tag_attributes = array();
						$bbcode_attributes = array();
						
						foreach ($parsed_child['node']->attributes as $attribute)
						{
							$tag_attributes[$attribute->nodeName] = "'" . $attribute->value . "'";
						}
						if (isset($parsed_child['vars']))
						{
							foreach ($parsed_child['vars'] as $var)
							{
								$replacement;
								if ($var['isAttribute'])
								{
									// TODO: Do this properly when decided about variable names
									$replacement = "attributes['" . $var['name'] . "']";
									$bbcode_attributes[$var['attr']] = $var['name'];
								}
								else
								{
									$replacement = '" + ' . xsl_parse_helper::EDITOR_JS_GLOBAL_OBJ . $var['prefixedName'] . ' + "';
								}
								$tag_attributes[$var['attr']] = 
									str_replace("'{\$" . $var['name'] . "}'", $replacement, $tag_attributes[$var['attr']]);
									
							}
						}				
						$js_var_name = $this->make_new_js_var($parsed_child['tagName'] . 'Tag');
						
						?>
						var <?=$js_var_name?> = document.createElement('<?=$parsed_child['tagName']?>');
<?php					
						foreach ($tag_attributes as $name => $value)
						{
						?>
						<?=$js_var_name?>.setAttribute('<?=$name?>', <?=$value?>);
<?php
							if(isset($bbcode_attributes[$name]))
							{
								?>
						<?=$js_var_name?>.setAttribute('data-bbcode-type', 'attr');
						<?=$js_var_name?>.setAttribute('data-bbcode-name', "<?=$bbcode_attributes[$name]?>");
						<?=$js_var_name?>.setAttribute('data-bbcode-value', attributes["<?=$var['name']?>"]);
<?php
							}
						}
						?>
<?php
					}

					$parsed_child['js']['type'] = 'NODE_DEFINITION';
					$parsed_child['js']['before'] = ob_get_contents();
					ob_clean();
					$parsed_child['js']['nodeName'] = $js_var_name;
					// $parsed_child['js']['after'] = '</' . $parsed_child['tagName'] . '>';
				}
				
				$node_children = &$parsed_child['children'];
				
				$this->parse_node($bbcode, $node_children);
			}
		}
	}
	
	
	public function join_template_js($append_to, $parent)
	{
		$js_join = '';

		foreach ($parent as $parsed_child)
		{
			if (isset($parsed_child['js']['before']))
			{
				if (isset($parsed_child['js']['type']))
				{
					$parent_node_name = $append_to;
					if ($parsed_child['js']['type'] === 'NODE_DEFINITION')
					{
						$js_join .= $parsed_child['js']['before'];
						if(isset($parsed_child['js']['parentEditable']) && $parsed_child['js']['parentEditable'])
						{
							?>
						<?=$append_to?>.setAttribute('data-bbcode-type', 'attr');
						<?=$append_to?>.setAttribute('data-bbcode-name', '<?=$parsed_child['js']['varName']?>');
						<?=$append_to?>.contentEditable = "true";
<?php
						}
						?>
						<?=$append_to?>.appendChild(<?=$parsed_child['js']['nodeName']?>);

<?php
						$js_join .= ob_get_contents();
						ob_clean();
						$parent_node_name = $parsed_child['js']['nodeName'];
					}
					else if ($parsed_child['js']['type'] === 'PARSED_CHILDREN_SET')
					{
						?>
						<?=$append_to?>.setAttribute('data-bbcode-type', 'content');
						<?=$append_to?>.contentEditable = "true";
						<?=$append_to?><?php
						$js_join .= ob_get_contents();
						ob_clean();
						$js_join .= $parsed_child['js']['before'];
					}
					else
					{
						$js_join .= $parsed_child['js']['before'];
					}
				}
				else
				{
					$js_join .= $parsed_child['js']['before'];
				}
			}
			
			if (isset($parsed_child['children']))
			{
				$js_join .= $this->join_template_js($parent_node_name, $parsed_child['children']);
			}
			else
			{
				$js_join .= $this->join_template_js($parent_node_name, $parsed_child['case']);
			}
			
			
			if (isset($parsed_child['js']['after']))
			{
				$js_join .= $parsed_child['js']['after'];
			}
		}
		return $js_join;
	}
	
	
	/**
	 * This converts the BBCode in the format that is in the database into a javascript output
	 * which is the instructions for the WYSIWYG editor on how to display all the BBCode and which BBCode
	 * to show up on the BBCode button list
	 *
	 *
	 *
	 */
	public function convert_bbcode_to_editor($text_formatter_factory)
	{
		
		$configurator = $text_formatter_factory->get_configurator();
		$configurator->addHTML5Rules();
		
		// var_dump($configurator->javascript);
		// var_dump($configurator->tags);
		// var_dump($configurator->tags['LIST']);
		
		
		$xsl_helper = new \phpbb\bbcode\xsl_parse_helper();
		$xsl_helper->translate_attribute_vars_to_params(true);
		$parsed_templates = $xsl_helper->parse_tag_templates($configurator->BBCodes, $configurator->tags);
		
		// var_dump($configurator->tags['quote']);
		// exit;
		
		// There is a lot of javascript output in this method that is meant to be caught like this.
		ob_start();
		
		$tag_id = 0;
		$bbcode_name = 'quote';
		$parsed_template = $parsed_templates[$bbcode_name];
		
		$js_text = '';
		
		?>
		$.sceditor.plugins.bbcode.bbcode.set('<?=$bbcode_name?>',
				{<?php
		$js_text .= ob_get_contents();
		ob_clean();
		
		
		$tags = $this->get_container_tags($parsed_template);
		$tags = array_unique($tags);
		?>
				tags: {
<?php
		foreach($tags as $htmlTag)
		{
			?>
			'<?=$htmlTag?>': {
				'data-tag-id': "<?=$tag_id?>"
			}
<?php
		}
		?>
					},
<?php
		$js_text .= ob_get_contents();
		ob_clean();
		?>		
					isInline: false,
					format: function (element, content) {
						var	author = '';
						var $elm  = $(element);
						var $cite = $elm.children('cite').first();

						if ($cite.length === 1 || $elm.data('author')) {
							author = $cite.text() || $elm.data('author');

							$elm.data('author', author);
							$cite.remove();

							content	= this.elementToBbcode($(element));
							author  = '=' + author.replace(/(^\s+|\s+$)/g, '');

							$elm.prepend($cite);
						}

						return '[quote' + author + ']' + content + '[/quote]';
					},
					html: function (token, attributes, content) {
		<?php
		$js_text .= ob_get_contents();
		ob_clean();
		
		$this->parse_node($bbcode_name, $parsed_template);
		
		// var_dump($parsed_template);
		
		// var_dump("------------------------------");
		
		?>
		var mainContainerFragment = document.createDocumentFragment();
		<?php
		$js_text = ob_get_contents();
		ob_clean();

		$js_text .= $this->join_template_js('mainContainerFragment', $parsed_template);
		
		?>
		
		if(mainContainerFragment.firstChild.getAttribute('contentEditable') !== 'yes'){
			mainContainerFragment.firstChild.contentEditable = 'false';
		}
		mainContainerFragment.firstChild.setAttribute('data-tag-id', "<?=$tag_id?>");
		return mainContainerFragment.firstChild.outerHTML;
		<?php
		$js_text .= ob_get_contents();
		ob_clean();
		
		var_dump($js_text);
		
		exit;
		foreach($configurator->BBCodes AS $bbcode)
		{
			var_dump($bbcode, $configurator->tags[$bbcode->tagName]);
			echo "<br>\n";
		}
		echo "-----------------------------------------------------------------
		-------------------------------------------------------------------
		--------------------------------------------------------------------
		-------------------------------------------------------------------------
		---------------------------------------------------------
		-----------------------------------------------------------------------
		-------------------------------
";
		// foreach( AS $bbcode)
		// {
			// var_dump($bbcode);
			// echo "<br>\n";
		// }
		exit;
		
		
		// return to normal. Do not discard all output to allow debugging
		
		ob_end_flush();
		
	}
	/*
		TextFormatter 		to 			SCE
		defaultChildRule				{forced:allow}
		defaultDescendantRule			{forced:allow}
		CloseParent						allowedChildren
		CloseParent						closedBy
		ignoreSurroundingWhitespace		{browser automatic}
		isNormalized					{Not needed}
		isTransparent					?
		filterChain->items->callback	Use to know the RegEx to use for validation
		attributePreprocessors			Extra RegEx to copy/parse data from an attribute to another
		attributes->defaultValue		Default value of attribute
		rules->autoReopen				{Doesn't have. Is it required?}
		AttributeFilter::AsURL			{Requires manual check for URL}
		
		
	*/

	/**
	 * This converts the smilies in the format that is in the database into a javascript output
	 * which is the instructions for the WYSIWYG editor on how to display all the smilies and which smilies
	 * to show up on the smilies list
	 *
	 *
	 *
	 */
	public function convert_smilies_to_editor()
	{
		
		
	}

	public static function get_name(){
		return 'SCE';
	}
	
	public static function get_available_button_modes()
	{
		return parent::HAS_BUTTON_MODE_ICON | parent::HAS_BUTTON_MODE_TEXT | parent::HAS_BUTTON_MODE_ICON_TEXT;
	}
	
}
