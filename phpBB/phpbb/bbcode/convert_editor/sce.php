<?php
/**
*
* This file is part of the phpBB Forum Software package.
*
* @copyright (c) phpBB Limited <https://www.phpbb.com>
* @license GNU General Public License, version 2 (GPL-2.0)
*
* For full copyright and license information, please see
* the docs/CREDITS.txt file.
*
*/

namespace phpbb\bbcode\convert_editor;

use s9e\TextFormatter\Configurator;
use s9e\TextFormatter\Plugins\BBCodes\Configurator as BBCodeConfigurator;
use s9e\TextFormatter\Configurator\Items\AttributeFilters\Regexp as RegexpFilter;
use s9e\TextFormatter\Configurator\Items\UnsafeTemplate;

use phpbb\bbcode\xsl_parse_helper as xsl_parse_helper;

function var_dump(){
	call_user_func_array("var_dump", func_get_args());
	ob_flush();
}

/**
*
* Note: This code includes ob_start() to ease the javascript building by having it syntax highlighted!
* 		Any use of var_dump() or any other output debugging should be used with that into account.
*
*/
class sce extends base
{

	
	/**
	 * Stores all js variables in order to avoid clashes
	 */
	protected $js_variables;
	
	protected $extra_variables;


	/**
	 * Constructor
	 * 
	 *
	 * @param \phpbb\cache\driver\driver_interface $cache Cache object
	 * @param string $cache_prefix A string to prefix to the cache file name (includes the path)
	 * @param \phpbb\config\config $config Config object
	 * @param \phpbb\event\dispatcher_interface $phpbb_dispatcher Where to send events to
	 */
	public function __construct(\phpbb\cache\driver\driver_interface $cache, $cache_prefix,
		\phpbb\config\config $config, \phpbb\event\dispatcher_interface $phpbb_dispatcher)
	{
		parent::__construct($cache, $cache_prefix, $config, $phpbb_dispatcher);
		
		$this->js_variables = array();
		$this->extra_variables = array();
		
		ob_start();
		// This is the topmost of the file. File editors support the embedded HTML with javascript.
		// This allows javascript code to be syntax highlighted by the editors.
		?><script><?php
		ob_end_clean();
	}
	
	
	/**
	 * @param string original_name A string tried as default value for name (eases readability later).
	 *								It gets suffixed with an integer if it was already defined.
	 * @return A string that has never been generated by this method, in this instance before
	 */
	protected function make_new_js_var($original_name)
	{
		if(!isset($this->js_variables[$original_name]))
		{
			$this->js_variables[$original_name] = 1;
			return $original_name;
		}
		
		$append = 0;
		do
		{
			$append++;
		}while(isset($this->js_variables[$original_name . $append]));
		
		$this->js_variables[$original_name . $append] = 1;
		return $original_name . $append;
		
	}
	
	protected function parse_case($bbcode_name, &$parsed_child)
	{
		
		$vars = array();
		foreach ($parsed_child['case'] as $test_result => &$execution)
		{
			foreach ($execution['vars'] as $execution_var)
			{
				if ($execution_var['isAttribute'])
				{
					$vars[$execution_var['name']] = 1;
				}
			}
			
			$this->parse_node($bbcode_name, $execution['children']);
?>
			case '<?=$test_result?>':
<?php 
			$execution['js']['type'] = 'SWITCH_CASE';
			$execution['js']['before'] = ob_get_contents();
			ob_clean();
			?>
			break;
<?php
			$execution['js']['after'] = ob_get_contents();
			ob_clean();
		}
		
		foreach ($vars as $var => $one)
		{
			?>
		xslt.setParameter('<?=$var?>', attributes['<?=$var?>']);
<?php
		}
		?>
		var conditionResult = xslt.transformToFragment(
			'<<?=$bbcode_name?> d="<?=$parsed_child['num']?>"></<?=$bbcode_name?>>',
			document
		).firstChild.nodeValue;
		
		switch(conditionResult[0]){
<?php
		$parsed_child['js']['type'] = 'SWITCH_DEFINITION';
		$parsed_child['js']['before'] = ob_get_contents();
		ob_clean();
		
?>
		}
<?php	
		
		$parsed_child['js']['after'] = ob_get_contents();
		ob_clean();
	}
	
	protected function parse_node($bbcode, &$parsed_template)
	{
		// This assumes that there are no text nodes simblings of each other
		// That not being true, however, has only a minor performance impact
		$strings = array();
		
		foreach ($parsed_template as &$parsed_child)
		{
			if (isset($parsed_child['case']))
			{
				$this->parse_case($bbcode, $parsed_child);
			}
			else
			{
				if ($parsed_child['xsl'])
				{
					switch ($parsed_child['tagName'])
					{						
						case 'apply-templates':
							
							?>.innerHTML += content;
<?php
							$parsed_child['js']['type'] = 'PARSED_CHILDREN_SET';
							$parsed_child['js']['before'] = ob_get_contents();
							ob_clean();
							
						break;
						case 'value-of':
							// Here it is easier due to how TextFormatter uses this tag
							$varData = $parsed_child['vars'][0];
							$js_var_name = $this->make_new_js_var('textNode');
							?>
						var <?=$js_var_name?> = document.createTextNode(<?php
							
							if ($varData['isAttribute'])
							{
								// TODO!! First check how variables in js code should be called
								?>attributes['<?=$varData['name']?>']<?php
							}
							else
							{
								echo xsl_parse_helper::EDITOR_JS_GLOBAL_OBJ . '.' . $varData['prefixedName'];
								$this->extra_variables[] = $varData['prefixedName'];
							}
						?>);
<?php					
							$parsed_child['js']['nodeName'] = $js_var_name;
							$parsed_child['js']['type'] = 'NODE_DEFINITION';
							$parsed_child['js']['parentEditable'] = $varData['isAttribute'];
							$parsed_child['js']['varName'] = $varData['name'];
							$parsed_child['js']['before'] = ob_get_contents();
							ob_clean();
						break;
						
						
					}
				}
				else
				{
					if ($parsed_child['tagName'][0] === '#')
					{
						// This is a text node. It requires special treatment
						$js_var_name = $this->make_new_js_var('textNode');
						?>
						var <?=$js_var_name?> = document.createTextNode('<?=$parsed_child['node']->data?>');
<?php					
					}
					else
					{	
						
						$tag_attributes = array();
						$bbcode_attributes = array();
						
						foreach ($parsed_child['node']->attributes as $attribute)
						{
							$tag_attributes[$attribute->nodeName] = "'" . $attribute->value . "'";
						}
						if (isset($parsed_child['vars']))
						{
							foreach ($parsed_child['vars'] as $var)
							{
								$tag_attributes[$var['attr']] = preg_replace_callback(
									// Note: The lookaround are required in case multiple variables are next to eachother
									"%((?<=[^'])|')" . preg_quote("{\${$var['name']}}", '%') . "((?=[^'])|')%",
									function ($match) use ($var, &$tag_attributes, $bbcode_attributes)
									{
										$replacement = '';
										if ($match[1] !== "'")
										{
											$replacement .= "' + ";
										}
										if ($var['isAttribute'])
										{
											$replacement .= "attributes['" . $var['name'] . "']";
											$bbcode_attributes[$var['attr']] = $var['name'];
										}
										else
										{
											$replacement = xsl_parse_helper::EDITOR_JS_GLOBAL_OBJ . '.' . $var['prefixedName'];
											$this->extra_variables[] = $var['prefixedName'];
										}
										if($match[2] !== "'")
										{
											$replacement .= " + '";
										}
										return $replacement;
									}, 
									$tag_attributes[$var['attr']]
								);
							}
						}				
						$js_var_name = $this->make_new_js_var($parsed_child['tagName'] . 'Tag');
						
						?>
						var <?=$js_var_name?> = document.createElement('<?=$parsed_child['tagName']?>');
<?php					
						foreach ($tag_attributes as $name => $value)
						{
						?>
						<?=$js_var_name?>.setAttribute('<?=$name?>', <?=$value?>);
<?php
							if(isset($bbcode_attributes[$name]))
							{
								// TODO: Make this a js function in assets/editor.js
								?>
						
						previousType = <?=$js_var_name?>.getAttribute('data-bbcode-type');
						attrData = <?=$js_var_name?>.getAttribute('data-bbcode-data') || [];
						
						attrData.push({
							name : "<?=$bbcode_attributes[$name]?>",
							value: attributes["<?=$bbcode_attributes[$name]?>"]
						});
								
						<?=$js_var_name?>.setAttribute('data-bbcode-type', 
							(previousType && previousType + '|attr')|| 'attr');
						<?=$js_var_name?>.setAttribute('data-bbcode-data', JSON.stringify(attrData));
<?php
							}
						}
						?>
<?php
					}

					$parsed_child['js']['type'] = 'NODE_DEFINITION';
					$parsed_child['js']['before'] = ob_get_contents();
					ob_clean();
					$parsed_child['js']['nodeName'] = $js_var_name;
					// $parsed_child['js']['after'] = '</' . $parsed_child['tagName'] . '>';
				}
				
				$node_children = &$parsed_child['children'];
				
				$this->parse_node($bbcode, $node_children);
			}
		}
	}
	
	
	public function join_template_js($append_to, $parent)
	{
		$js_join = '';

		foreach ($parent as $parsed_child)
		{
			if (isset($parsed_child['js']['before']))
			{
				if (isset($parsed_child['js']['type']))
				{
					$parent_node_name = $append_to;
					if ($parsed_child['js']['type'] === 'NODE_DEFINITION')
					{
						$js_join .= $parsed_child['js']['before'];
						if(isset($parsed_child['js']['parentEditable']) && $parsed_child['js']['parentEditable'])
						{
							// It's OK to use the "|"(pipe) as separator as it is an illegal character for a tag (but not in a value)
							$varName = $parsed_child['js']['varName'];
							?>
						previousType = <?=$append_to?>.getAttribute('data-bbcode-type');
						attrData = <?=$append_to?>.getAttribute('data-bbcode-data') || [];
						
						attrData.push({
							name : "<?=$varName?>",
							value: editorConstants.VALUE_IN_CONTENT
						});
								
						<?=$append_to?>.setAttribute('data-bbcode-type', 
							(previousType && previousType + '|attr')|| 'attr');
						<?=$append_to?>.setAttribute('data-bbcode-data',JSON.stringify(attrData))
						<?=$append_to?>.contentEditable = "true";
<?php
						}
						?>
						<?=$append_to?>.appendChild(<?=$parsed_child['js']['nodeName']?>);

<?php
						$js_join .= ob_get_contents();
						ob_clean();
						$parent_node_name = $parsed_child['js']['nodeName'];
					}
					else if ($parsed_child['js']['type'] === 'PARSED_CHILDREN_SET')
					{
						?>
						previousType = <?=$append_to?>.getAttribute('data-bbcode-type');
						<?=$append_to?>.setAttribute('data-bbcode-type', 
							(previousType && previousType + '|content')|| 'content');
						<?=$append_to?>.contentEditable = "true";
						<?=$append_to?><?php
						$js_join .= ob_get_contents();
						ob_clean();
						$js_join .= $parsed_child['js']['before'];
					}
					else
					{
						$js_join .= $parsed_child['js']['before'];
					}
				}
				else
				{
					$js_join .= $parsed_child['js']['before'];
				}
			}
			
			if (isset($parsed_child['children']))
			{
				$js_join .= $this->join_template_js($parent_node_name, $parsed_child['children']);
			}
			else
			{
				$js_join .= $this->join_template_js($parent_node_name, $parsed_child['case']);
			}
			
			
			if (isset($parsed_child['js']['after']))
			{
				$js_join .= $parsed_child['js']['after'];
			}
		}
		return $js_join;
	}
	
	
	/**
	 * This converts the BBCode in the format that is in the database into a javascript output
	 * which is the instructions for the WYSIWYG editor on how to display all the BBCode and which BBCode
	 * to show up on the BBCode button list
	 *
	 *
	 *
	 */
	public function generate_editor_setup_javascript($text_formatter_factory)
	{
		
		$configurator = $text_formatter_factory->get_configurator();
		$configurator->addHTML5Rules();
		$configurator->enableJavaScript();
		 // echo "a";
		
		// var_dump($configurator->javascript);
		// var_dump($configurator->BBcodes);
		// var_dump($configurator->tags);
		// var_dump($configurator->BBCodes['bug']);
		// var_dump($configurator->tags['bug']);
		// var_dump($configurator->BBCodes['hr']);
		// var_dump($configurator->tags['hr']);
		// var_dump($configurator->BBCodes['CODE']);
		// var_dump($configurator->tags['CODE']);
		// var_dump($configurator->BBCodes['LIST']);
		// var_dump($configurator->tags['LIST']);
		// var_dump($configurator->BBCodes['*']);
		// var_dump($configurator->tags['li']);
		// exit;
		
		
		$xsl_helper = new \phpbb\bbcode\xsl_parse_helper();
		$xsl_helper->translate_attribute_vars_to_params(true);
		$parsed_templates = $xsl_helper->parse_tag_templates($configurator->BBCodes, $configurator->tags);
		$xsl_text = $xsl_helper->get_built_xsl_sheet();
		
		
		// foreach ($configurator->BBCodes AS $bbcode){
			// var_dump($bbcode);
			// var_dump($configurator->tags[$bbcode->tagName]);
		// }
		// foreach ($configurator->BBCodes AS $name => $bbcode){
			// var_dump($name);
			// var_dump($configurator->tags[$bbcode->tagName]);
			// foreach ($configurator->tags[$bbcode->tagName]->attributes as $attr){
				// // var_dump($attr);
				// foreach ($attr->filterChain as $filter){
					// if($filter->getJS()){
						// var_dump($filter->getJS()->__toString());
					// }else{
						// var_dump("");
					// }
						// // var_dump($attr->filterChain);
						// // var_dump($filter->getJS());
					
				// }
			// }
		// }
		
		
		// exit;
		
		$tagnames = array();
		foreach ($configurator->tags as $name => $data)
		{
			$tagnames[] = $name;
		}
		
		// There is a lot of javascript output in this method that is meant to be caught like this.
		ob_start();
		
		
		?>
		
		xslt = xslt('<?=str_replace("\n", "' +\n'", addcslashes($xsl_text, "'"))?>');
<?php
		
		$tag_id = -1;
		$js_texts = array();
		
		foreach ($configurator->BBCodes as $bbcode_name => $bbcode)
		{
			$tag_id++;
			$bbcode_name = strtolower($bbcode_name);
			
			$parsed_template = $parsed_templates[$bbcode_name];
			
			$tag = $configurator->tags[$bbcode->tagName];
			
			$bbcode_data = $this->extract_and_normalize_bbcode_data($bbcode, $tag, $tagnames);
			
			// var_dump($bbcode_data);
			// exit;
			$js_text = '';
			
			?>
	$.sceditor.plugins.bbcode.bbcode.set('<?=$bbcode_name?>',
			{
<?php
			$js_text .= ob_get_contents();
			ob_clean();
			
			
			$tags = $this->get_container_tags($parsed_template);
			$tags = array_unique($tags);
			?>
				tags: {
<?php
			foreach($tags as $htmlTag)
			{
				?>
					'<?=$htmlTag?>': {
						'data-tag-id': "<?=$tag_id?>"
					}
<?php
			}
			?>
				},
<?php
			$js_text .= ob_get_contents();
			ob_clean();
			?>		
				isInline: false,
<?php				
			if (isset($bbcode_data['autoCloseOn']))
			{
				?>
				excludeClosing: true,
<?php
			}
	?>
<?php		
			if (empty($bbcode_data['useContent']) &&
				(!empty($bbcode_data['autoClose']) || 
					(!empty($bbcode_data['ignoreBBCodeInside']) && !empty($bbcode_data['ignoreTextInside'])))
				)
			{
				?>
				isSelfClosing: true,
<?php
			}
			else if (empty($bbcode_data['ignoreBBCodeInside']))
			{
				?>
				allowedChildren: ['#'],
<?php
			}
			else if (!empty($bbcode_data['allowedChildren']))
			{
				?>
				allowedChildren: ['<?php
				echo !empty($bbcode_data['ignoreTextInside']) ? "" : "#','";
				echo implode("','", array_map('strtolower', $bbcode_data['allowedChildren']));
				?>'],
<?php
			}
			?>
				allowsEmpty : true,
				html: function (token, attributes, content) {
					var originalAttributes = attributes;
					var originalContent = content;
					var previousType;
					var attrData;
					var usedContents = [];
<?php
			if($bbcode_data['defaultAttribute'])
			{
				?>
					if(!attributes["<?=$bbcode_data['defaultAttribute']?>"] &&
						attributes["<?=$bbcode_data['defaultAttribute']?>"] !=== '' && attributes.defaultattr){
						attributes["<?=$bbcode_data['defaultAttribute']?>"] = attributes.defaultattr;
					}	
<?php
			}
			?>
<?php
			foreach($bbcode_data['useContent'] as $use_content_attr)
			{
				?>
					if(!attributes["<?=$use_content_attr?>"] &&
						attributes["<?=$use_content_attr?>"] !=== '' && 
						(content || content === '')						
						){
						attributes["<?=$use_content_attr?>"] = content;
						usedContents.push("<?=$use_content_attr?>");
					}	
<?php
			}
			?>
<?php
			foreach ($bbcode_data['attrPresets'] as $name => $value)
			{
				?>
					if(!attributes['<?=$name?>'] && attributes['<?=$name?>'] !== ''){
						attributes['<?=$name?>'] = <?=addcslashes($value, "'")?>;
					}	
<?php
			}
			if(!empty($bbcode_data['preProcessors'])){
				?>
				var searchResult;
<?php
				foreach ($bbcode_data['preProcessors'] as $pre_processor)
				{
					?>
				searchResult = <?=$pre_processor['regexFixed']?>.exec(attributes['<?=$pre_processor['sourceAttribute']?>']);
				if(searchResult){
<?php
					foreach ($pre_processor['matchNumVsAttr'] as $num => $attr)
					{
					?>
					if(!attributes["<?=$use_content_attr?>"] && attributes["<?=$use_content_attr?>"] !=== ''){
						attributes['<?=$attr?>'] = searchResult[<?=$num?>];
					}
<?php
					}
					?>
				}
<?php	
				}
			}

			foreach ($bbcode_data['attr'] as $attr_name => $attr_data)
			{
				foreach ($attr_data['filters'] as $filter)
				{
					if (isset($filter['name']))
					{
						?>
						attributes['<?=$attr_name?>'] = 
							editor.paramFilters['<?=$filter['name']?>'](attributes['<?=$attr_name?>']<?=$filter['extraVars']?>);
<?php
					}
					else
					{
						?>
						attributes['<?=$attr_name?>'] = 
							(<?=$filter['inlineFunc']?>)(attributes['<?=$attr_name?>']<?=$filter['extraVars']?>);
<?php
					}
				?>	
					if(attributes['<?=$attr_name?>'] === false){
						console.warn("Attribute <?=$attr_name?> from BBCode <?=$bbcode_name?> failed to validate <?=isset($filter['name']) ? $filter['name'] : addcslashes($filter['inlineFunc'], "\n\"")?>");
					}
<?php
				}
				if ($attr_data['defaultValue'])
				{
				?>				
					if(!attributes['<?=$attr_name?>'] && attributes['<?=$attr_name?>'] !== ''){
						attributes['<?=$attr_name?>'] = "<?=$attr_data['defaultValue']?>";
					}
<?php
				}
				if ($attr_data['required'])
				{
				?>				
					if(!attributes['<?=$attr_name?>'] && attributes['<?=$attr_name?>'] !== ''){
						return editor.revertBackToBBCode("<?=$bbcode_name?>", originalAttributes, originalContent);
					}
<?php
				}
			}
			?>
<?php
			$js_text .= ob_get_contents();
			ob_clean();
			
			$this->parse_node($bbcode_name, $parsed_template);
			
			// var_dump($parsed_template);
			
			// var_dump("------------------------------");
			
			?>
			var mainContainerFragment = document.createDocumentFragment();
			<?php
			$js_text .= ob_get_contents();
			ob_clean();

			$js_text .= $this->join_template_js('mainContainerFragment', $parsed_template);
			
			?>
			
				if(mainContainerFragment.firstChild.getAttribute('contentEditable') !== 'yes'){
					mainContainerFragment.firstChild.contentEditable = 'false';
				}
				mainContainerFragment.firstChild.setAttribute('data-tag-id', "<?=$tag_id?>");
				return mainContainerFragment.firstChild.outerHTML;
			},
			<?php
			$js_text .= ob_get_contents();
			ob_clean();
			?>
				format: function (element, content) {
					var infos = element.querySelectorAll('[data-bbcode-type]');
					var params = [];
					var useContent = false;
					
					for(var i = 0; i < infos.length; i++){
						var current = infos[i];
						var type = current.getAttribute('data-bbcode-type');
						var data = current.getAttribute('data-bbcode-data');
						if(!type){
							console.error("To BBCode translation error at BBCode <?=$bbcode_name?>.\n" 
										+ "Unexpected empty data-bbcode-type parameter. Value and node as follows:");
							console.error(type);
							console.error(current);
							return;
						}
						var types = type.split("|");
						var data = JSON.parse(data);
						var extraOffset = 0;
						for(var j = 0; j < types.length; j++){
							if(types[j] === 'content'){
								useContent = true;
								extraOffset--;
							}else if(types[j] === 'attr'){
								var name = data[j + extraOffset].name;
								var value = data[j + extraOffset].value;
								if(value === editorConstants.VALUE_IN_CONTENT){
									value = current.textContent;
								}
								params.push(
									name + '="' + value + '"'
								);
							}else{
								console.warn("To BBCode translation warning at BBCode <?=$bbcode_name?>.\n" + 
											 "Unexpected value for data-bbcode-type parameter." + 
											 "Skipping to the next value. Value and node were as follows:");
								console.warn(types[j]);
								console.warn(types);
								console.warn(current);
								continue;
							}
						}
					}
					
					return '[<?=$bbcode_name?>' + 
						(params ? ' ' : '') +
						params.join(' ') +
						']' + (useContent ? content : '') + '[/<?=$bbcode_name?>]';
				}
			});
<?php
			$js_text .= ob_get_contents();
			ob_clean();
			
			$js_texts[] = $js_text;
		}
		
		?>
		var <?=xsl_parse_helper::EDITOR_JS_GLOBAL_OBJ?> = {
<?php
		foreach ($this->extra_variables as $editor_data_var)
		{
?>
			'<?=$editor_data_var?>': '{<?=$editor_data_var?>}',
		var_dump($this->extra_variables);
<?php	
		}
?>
		};
<?php	
		return implode($js_texts, "\n\t");
		
		foreach($configurator->BBCodes AS $bbcode)
		{
			var_dump($bbcode, $configurator->tags[$bbcode->tagName]);
			echo "<br>\n";
		}
		echo "-----------------------------------------------------------------
		-------------------------------------------------------------------
		--------------------------------------------------------------------
		-------------------------------------------------------------------------
		---------------------------------------------------------
		-----------------------------------------------------------------------
		-------------------------------
";
		// foreach( AS $bbcode)
		// {
			// var_dump($bbcode);
			// echo "<br>\n";
		// }
		exit;
		
		
		// return to normal. Do not discard all output to allow debugging
		
		ob_end_flush();
		
	}
	/*
		TextFormatter 		to 			SCE
		defaultChildRule				{forced:allow}
		defaultDescendantRule			{forced:allow}
		CloseParent						allowedChildren
		CloseParent						closedBy
		ignoreSurroundingWhitespace		{browser automatic}
		isNormalized					{Not needed}
		isTransparent					?
		filterChain->items->callback	Use to know the RegEx to use for validation
		attributePreprocessors			Extra RegEx to copy/parse data from an attribute to another
		attributes->defaultValue		Default value of attribute
		rules->autoReopen				{Doesn't have. Is it required?}
		AttributeFilter::AsURL			{Requires manual check for URL}
		
		
	*/

	/**
	 * This converts the smilies in the format that is in the database into a javascript output
	 * which is the instructions for the WYSIWYG editor on how to display all the smilies and which smilies
	 * to show up on the smilies list
	 *
	 *
	 *
	 */
	public function convert_smilies_to_editor()
	{
		
		
	}

	public static function get_name(){
		return 'SCE';
	}
	
	public static function get_available_button_modes()
	{
		return parent::HAS_BUTTON_MODE_ICON | parent::HAS_BUTTON_MODE_TEXT | parent::HAS_BUTTON_MODE_ICON_TEXT;
	}
	
}
